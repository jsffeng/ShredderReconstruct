//////////////////////////////////////////////////////////////////////////////////////////  
//
//  Naming convention used in source code and header files in this programme.
//
//  Let's assume the following text content to be unshredded by this programme.
//  
//  a1|a2|a3
//  b1|b2|b3
//  c1|c2|c3
//  d1|d2|d3
// 
//  In abvoe, a1, a2, b1, etc. is a string with same width, "|" is delimiter used by programme.
//
//  In this programme, above data will be stored into following 2 dimentional vector:
//  {
//    {a1,b1,c1,d1},
//    {a2,b2,c2,d2},
//    {a3,b3,c3,d3}
//  }
//  
//  A text strip refer to {a1,b1,c1,d1}, or {a2,b2,c2,d2}, etc in above. 
//  A "column" often used to refer a text strip in data or variables in this programme.
//  
//////////////////////////////////////////////////////////////////////////////////////////  

#include <boost/algorithm/string.hpp>
#include "common_class.h"
#include "unshredder.h"
#include "singleton_diction.h"
const float kToleranceRate = 0.15;

// Class ColumnMatchManager constructor
ColumnMatchManager::ColumnMatchManager(vector<vector<string>> & vec_text_columns,vector<string> & vec_new_column)
{
  vec_text_columns_.assign(vec_text_columns.begin(), vec_text_columns.end());
  vec_new_column_.assign(vec_new_column.begin(),vec_new_colum.end());
}

// Class ColumnMatchManager
// Result stored to vec_key_column
void ColumnMatchManager::BuildLookupKey(vector<string> &vec_key_column, TwoWayDirections enum_direct) 
{
  vector<string> vec_merged_column;
  vector<string> vec_temp;
  string str_key_t;

  if (!vec_key_column.empty())
    vec_key_column.clear();

  if (vec_text_columns_.empty())
    throw runtime_error("vec_text_columns_ is empty, no data to match!");

  // Merged text stored in vec_merged_column
  TextStripOperation::MergeText(vec_text_columns_, vec_merged_column);

  for (int i = 0; i < vec_new_column_.size(), ++i)
  {

    if (enum_direct == LEFT)
    {
      str_key_t = vec_new_column_[i] + vec_merged_column[i];
      boost::split(vec_temp, str_key_t, boost::is_any_of(" ,.:;\\\?\'\"-)(]["));
      str_key_t = *vec_temp.begin(); 
    }
    else
    {
      str_key_t = vec_merged_column[i] + vec_new_column_[i];
      boost::split(vec_temp, str_key_t, boost::is_any_of(" ,.:;\\\?\'\"-)(]["));
      str_key_t = *(vec_temp.end() - 1); 
    }
  
    //remove 's ????
    //split for  ' ', ',', '.', '?', '\'', '\"', '-', ')', '(', 
    //Don't serach if Upper case,
    // If any number, don't search, isdigit, isupper?
    // if length less than 2, don't search
    if (str_key_t.size() <= 2 )
      str_key_t = " ";

    vec_key_column.push_back(str_key_t);
  } 
}

// class ColumnMatchManager
// If not found in dictionary, removing suffix such as ed|ing|s|es for re-searching
bool RemoveKeySuffix(string &str_lookup_key)
{
  vector<string> vec_suffix = {"ing", "ed", "es", "s"};

  int n_position = str_lookup_key.size(); 
  int n_position_t, n_length_t;
  bool b_remove_suffix = false;

  auto iter = vec_suffix.begin();
  
  while (iter != vec_suffix.end()) 
  {
    n_length_t = iter->size();
    n_position_t = n_position - n_length_t;

    // Need to ensure the remaining letters are equal or greater than 2 after removing suffix
    if (n_position_t >= 2) 
    {
      if (str_lookup_key.compare(n_position_t,n_length_t,*iter) == 0)
      { 
        str_lookup_key = str_lookup_key.substr(0, n_position_t - 1); 
        b_remove_suffix = true;
        break;
      }
    }
    ++iter;
  }

  return b_remove_suffix;

}

// class ColumnMatchManager
void ColumnMatchManager::CalculateMatchRate()
{
  vector<string> vec_word_column;

  int n_found = 0;
  int n_notfound = 0;
  bool b_flag_lookup, b_flag_suffix;

  SingletonDiction & singleton_dict = SingletonDiction::GetInstance();

  for(TwoWayDirections i = LEFT; i < LIMIT; i = (TwoWayDirections)(i+1))
  {
    BuildLookupKey(vec_word_column, i);
   
    for (int k = 0; k < vec_word_column.size(); ++k) 
    { 
      if (!vec_word_column[k].empty()) 
      {
        b_flag_lookup = singleton_dict.LookupDict(vec_word_column[k]);

        if (b_flag_lookup == true)
        {
          ++n_found;
        }
        else
        {
          // If not found in dictionary, removing suffix such as ed|ing|s|es if there is.
          b_flag_suffix = RemoveKeySuffix(vec_word_column[k]);
          if (b_flag_suffix == true)
          {
            b_flag_lookup = singleton_dict.LookupDict(vec_word_column[k]);
   
            if (b_flag_lookup == true)
              ++n_found;
            else
              ++n_notfound;
          }
          else
          {
            ++n_notfound;
          }
        }
      }
    }

    column_match_rate_[i].f_match_rate = (n_found + 1)/(n_notfound + 1);
    column_match_rate_[i].f_notmatch_rate = n_notfound/vec_word_column.size();

    vec_word_column.clear(); 
  }
}

// Class ColumnSelectManager constructor
ColumnSelectManager::ColumnSelectManager()
{
}

// Class ColumnSelectManager
// Init vec_selected_columns_ and vec_column_pool_ with columns. 
void ColumnSelectManager::Init(vector<vector<string>> columns)
{
}

// Class ColumnSelectManager
void ColumnSelectManager::FindBestMatch()
{
   MatchRate match_rate_t;
   TwoWayDirections enum_direct_t;

   int n_number = -1;
   float f_best_match = 0;

   int i = 0;
   auto iter = vec_column_pool_.begin();
   while (iter != vec_column_pool_.end() )
   {
       ColumnMatchManager p_column_match_manager = new ColumnMatchManager(vec_selected_columns_, *iter); 
       
       p_column_match_manager->CalculateMatchRate();
       for(TwoWayDirections j=LEFT ;j<LIMIT; j=(TwoWayDirections)(j+1))
       {
          match_rate_t = p_column_match_manager->column_match_rate_[j];
         if (match_rate_t.f_notmatch_rate > kToleranceRate)
         {
 	       continue;
         }
 	   else
         {
            if (match_rate_t.f_match_rate > f_best_match)
            {
 	         f_best_match = match_rate_t.f_match_rate;
 	         n_number = i;
                 enum_direct_t = j;
            }
         }
       }

       delete p_column_match_manager;
       ++iter;
       ++i;
   }

   if (n_number == -1)
   {
      //Failed to find any matching columns! May need to change parameter and re-try.
      b_failure_flag_ = true;
   }
   else
   { 
     best_match_column_.n_number_in_pool = n_number; 
     best_match_column_.enum_best_match_direct = enum_direct_t;
   }
}

// Class ColumnSelectManager
void ColumnSelectManager::AddToSelectedColumns()
{     
  if (best_match_column_.n_number_in_pool == -1) 
    throw runtime_error("Invalid input!");

   vector<string> vec_column = vec_column_pool_[vec_column_pool_.n_number_in_pool];

  // Reset the following is -1 after adding it to vec_selected_columns_
  best_match_column_.n_number_in_pool == -1;
}


// Class ColumnSelectManager
void ColumnSelectManager::DeleteFromColumnPool()
{
}

// Class ColumnSelectManager
int TextUnshredder::RebuildColumnsByBestMatch()
{
  int n_column_pool_number_t;
  TwoWayDirections enum_direct_t;

  FindBestMatch(n_column_pool_number_t, enum_direct_t);

  if (b_failure_flag_ == true ) 
     return 1; 
  //reconstruct  vec_selected_columns_ with num and enum_direct;
  AddToSelectedColumns();

  //reconstruct vec_column_pool_ with num and enum_direct;
  DeleteFromColumnPool();
  
  return 0;
}

// Class TextUnshredder constructor
TextUnshredder::TextUnshredder(const string str_in_file, const string str_out_file)
{
}

// Class TextUnshredder
void TextUnshredder::GetInput()
{
}

// Class TextUnshredder
void TextUnshredder::CreateOutput()
{
}

// Class TextUnshredder
void TextUnshredder::DoTextUnshredder()
{

 column_select_manager_.Init(vec_text_columns_);
 while (column_select_manager_.vec_column_pool_ ! = NULL && column_select_manager_.b_failure_flag_ == false)
 { 
   column_select_manager_.RebuildColumnsByBestMatch();
 }

// vector<string> vec_merged_text_trans;
 if (column_select_manager_.b_failure_flag_ == true) 
 {
  // b_premature_flag_ = true, n_premature_column_number_ = size of column_select_manager_.vec_column_pool_
  // combine column_select_manager_.vec_selected_columns_ and column_select_manager_.vec_column_pool_ 
     column_select_manager_.best_match_column_.enum_best_match_direct = RIGHT;
     for (int i=0; i< sizeof(column_select_manager_.vec_column_pool_); i++) 
     {
       column_select_manager_.best_match_column_.n_number_in_pool = i; 
       column_select_manager_.AddToSelectedColumns();
     }
 }

 TextStripOperation::MergeText(column_select_manager_.vec_selected_columns_,vec_merged_text_);
 //TextStripOperation::Transpose(vec_merged_text_trans, vec_merged_text_);

}

