########### Common Classes Start ############
TextFileOperation
---------------------------------------
+ static ReadText(const string str_filename, vector<std::string> &vec_str_text_lines) : void
# Newly-added, used to read dictionary into set 
+ static ReadText(const string str_filename, set<string> &set_str_text_lines) : void
+ static WriteText(const string str_filename, const vector<std::string> vec_str_text_lines) : void
---------------------------------------

TextStripOperation
---------------------------------------
- static const int s_random_number_
---------------------------------------
+ static Disorder(vector<vector<string>>& vec_str_input) : void
+ static Transpose(vector<vector<string>>& vec_str_input, vector<vector<string>>& vec_str_input_trans) : void
# Newly-added to support unshredder
+ static MergeText(vector<vector<string>> & vec_str_input, vector<string>& vec_str_text): void
---------------------------------------

StringWordOperation
---------------------------------------
+ static RemoveWordSuffix(string &str_lookup_key): bool
+ static FindLookupWordLeft(string & str_line, string & str_key, int n_column_width): void
+ static FindLookupWordRight(string & str_line, string & str_key, int n_column_width): void
---------------------------------------

SingletonDiction
---------------------------------------
- set<string> set_dictionary_
---------------------------------------
+ static GetInstance() : SingletonDiction &
+ Init() : void
+ BuildWordPiece() : void
+ LookupDict(string str_letters) : bool
---------------------------------------
########### Common Classes End ############

########### Regular Classes Start ############
# Global data types used by multiple classes
typedef struct {
	float f_match_rate;
	float f_notmatch_rate;
} MatchRate;


typedef enum 
{
    LEFT = 0,
    RIGHT,
    LIMIT=2
} TwoWayDirections;

# Global const used by programme
const float kToleranceRate = 0.25;
const kAcceptableMatchRate = 1;

ColumnMatchManager
---------------------------------------
- vector<vector<string>> vec_text_columns_
- vector<string> vec_new_column_
# Store match rate from LEFT side and RIGHT side
+ MatchRate column_match_rate_[LIMIT];
---------------------------------------
+ ColumnMatchManager (vector<vector<string>> vec_text_columns,vector<string> vec_new_column)
# Populate column_match_rate_[];
+ CalculateMatchRate (): void 
# Called by CalculateMatchRate
- BuildLookupKey(vector<string> &vec_key_column, TwoWayDirections enum_direct): void
---------------------------------------

ColumnSelectManager
---------------------------------------
- typedef struct {
   int n_number_in_pool;
   TwoWayDirections enum_best_match_direct;
  } BestMatchColumn;
+ BestMatchColumn best_match_column_;
+ vector<vector<string>> vec_selected_columns_;
+ vector<vector<string>> vec_column_pool_;
# b_failure_flag_ default is false, true means no matching can be found in vec_column_pool_.
+ bool b_failure_flag_;
---------------------------------------
# Setup best_match_column_.n_number_in_pool=-1,best_match_column_.enum_best_match_direct=LEFT
# Setup b_failure_flag_ = false
+ ColumnSelectManager();
+ Init(const vector<vector<string>> & vec_text_columns) : void
# Find the best matching column and move it from vec_column_pool_ to vec_selected_columns_
+ RebuildColumnsByBestMatch() : void
+ AddToSelectedColumns() : void
# Called only by RebuildColumnsByBestMatch 
# Find best match in vec_column_pool_, if found, populate best_match_column_ , if fail, set
# b_failure_flag_ true
- FindBestMatch() : void
- DeleteFromColumnPool() : void
---------------------------------------

# To construct text strips to a text page
TextUnshredder
---------------------------------------
# Store text data read from GetInput()
+ vector<vector<string>> vec_text_columns_
# Store final result
+ vector<string> vec_merged_text_
+ bool b_premature_flag_
# Size of unselected columns
+ int n_premature_column_count_
- ColumnSelectManager column_select_manager_
---------------------------------------
# b_premature_flag_ = false, n_premature_column_count_ = 0
+ TextUnshredder()
# Populate vec_text_columns_ from input file, with calling text_strip::transpose
+ GetInput(const string str_in_file) : void
+ DoTextUnshredder() : void
# Generate final output file
+ CreateOutput(const string str_out_file) : void
---------------------------------------
########### Regular Classes End ###############

########### ThreadController Class Start ###############
typedef enum 
{
    NOTSTART = 0,
    PARTICIAL = 1,
    SUCCESS = 2
} ThreadStatus;


ThreadController
---------------------------------------
# mutex for all threads
- static mutex status_mutex_;
- static mutex data_mutex_;
# Store final result, default contain blank strings
+ static vector<string> vec_final_merged_text_
# default b_premature_flag_ = false
+ static bool b_premature_flag_
# Size of unselected columns, default n_premature_column_count_ = 0
+ static int n_premature_column_count_
# default thread_status_ = NOTSTART
- static ThreadStatus thread_status_
# Increase the number any exception throw from a thread
+ static int n_thread_abnormals_
---------------------------------------
+ static DoTextUnshredderInThread(TextUnshredder text_unshred) : int
- static UpdateThreadStatus(ThreadStatus status) : void
- static RecordThreadResult(vector<string> vec_final_merged_text, int n_premature_column_count,bool b_premature_flag) : void
- static RecordThreadAbnormals() : void
---------------------------------------
########### ThreadController Class End #################

Class relationship:
==================

                             TextStripOperation 
                                     ^
                                     :
                                     :
                                     :(dependency)
                                     :
                 (dependency)        :       (dependency) 
ThreadController ------------>TextUnshredder ------------> TextFileOperation
                                     |
                                     | 
                                     |(association)
                                     |
                                     |
                                     V            (dependency)
                              ColumnSelectManage ------------> TextStripOperation (depending on SingletonRandom)
                                     :
                                     :
                                     :(dependency)
                                     :
                                     :
                                     V           (dependency)
                              ColumnMatchManager ------------> StringWordOperation
                                     : 
                                     :
                                     : (dependency)
                                     :
                                     V
                              SingletonDiction



Main algorithm to reconstruct the disordered text columns (aka text strips):
==================================================================
In the following context, the columns which have been successfully re-constructed called as SELECTED COLUMNS, the remaining columns called COLUMN POOL.  
1. Randomly select a column, and create initial SELECTED COLUMNS with this only one column. And all the rest columns will be put into COLUMN POOL.  

2. For each column in COLUMN POOL, calcuate the following matching rate to the SELECTED COLUMNS from LEFT and RIGHT direction, respectively.
  - f_match_rate = (Found + 1)/(NotFound + 1),
  - f_notmatch_rate = NotFound/AllRow,

    Note:
    Found is the number of the strings (or saying partial words) can be found in dictionry after appended to SELECTED COLUMNS.  The higher of this value, the higher the maching rate.
    NotFound is the number of the the strings (or saying partial words) cannot be found in dictionry after appended to SELECTED COLUMNS. The lower of this value, the higher the matching rate.
    AllRow is the number of rows.

    f_match_rate is the overall matching rate. The higher of this value, the higher the overall matching rate.
    f_notmatch_rate is used to meansure the level of not matching. The higher of this value, the less likely to match.

    When caculating Found or NotFound, non-alphabetic strings or the strings with length less than 2 charactors will be ignored for dictionary lookup.  
    Take a set of columns containing 10 rows as example, (i.e. AllRow = 10),the value range of f_match_rate will be 0.09 ~ 11 (i.e. 1/11 ~ 11).

    f_notmatch_rate ranges from 0 ~ 100% (i.e. 0 ~ 1)

    If f_match_rate is above pre-defined value kAcceptableMatchRate, will be treated as valid. Otherise, just ingore the further processing. 
    
    f_notmatch_rate is above pre-defined value kToleranceRate=25%, will be treated as valid. Otherise, just ingore the further processing.

3. Go through all columns in COLUMN POOL to compare their matching rate, and find the best matching and then add into SELECTED COLUMNS. Then remove it from COLUMN POOL.
The stragery to find best matching is:
  - columns with f_notmatch_rate > kToleranceRate, won't be considered as candiates.
  - columns with f_match_rate <= kAcceptableMatchRate, won't be considered as candiates.
  - All the rest columns will be considered as the candiates, and pick the one with largest f_match_rate as the best matching.
  - If no such column exists (after discarding those with f_notmatch_rate > kToleranceRate and f_match_rate <= kAcceptableMatchRate), the programme will be marked as pre-matured and terminate with the partial result being provided.

4. Repeat step 2 - step 3.
  - If no columns left in COLUMN POOL, completes successuflly. 

5. Simulating test shows whether the programme can complete successfully is sensative to the initial SELECTED COLUMNS (i.e the first selected column to be chosen). 
Under the same condition, with choosing differenct the initial SELECTED COLUMNS, ~80% cases may lead to pre-matured situation, while ~20% cases may lead to successful result.
This is understandable by considering some columns (especially containing many blank lines) are easy to be matched by multiple columns, which may lead to the pre-majure of the algorithm in later processing.
With this fact, decided to choose multi-thread (10 threads used by default) to enhance the programme and choose the best one as the final result.

**Note**:  
Avove algorithm is kind of simulating people's mind to re-construct text strips, however, sometimes, it is really hard or impossible to successfully complete the 100% restoration, depending on the real text strip content. 
But another fact is that more rows text strips have, the higher successful completion rate the programme may achieve.
The rationale is that more rows usually mean more characteristics for a column when compare with others.
Based on a variety of testings, we could expect that the regular text (i.e. from books, newspaper, magazines, etc.) with above 15 rows can 100% restored by this programe. 

